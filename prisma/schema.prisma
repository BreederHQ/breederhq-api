// ------------------------------------------------------------
// Prisma Client generator + datasource (dev-friendly)
// ------------------------------------------------------------
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"

  // Runtime connections (app/dev servers, Prisma Studio):
  // Use your *pooled* app role here (the one you already had).
  url = env("DATABASE_URL")

  // Shadow DB for migrations in dev (owner is fine here).
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")

  // ðŸš© Migrations use this URL instead of DATABASE_URL.
  // Point it to the *OWNER* role and the *non-pooled* host.
  directUrl = env("MIGRATE_DATABASE_URL")
}

// ------------------------------------------------------------
// Enums
// ------------------------------------------------------------

// Auth / tokens
enum VerificationTokenType {
  MAGIC_LINK
  INVITE
  EMAIL_VERIFY
  RESET
}

// Org membership roles
enum Role {
  STAFF
  ADMIN
  MEMBER
  VIEWER
}

// Contacts
enum ContactStatus {
  ACTIVE
  INACTIVE
}

enum CommStatus {
  SUBSCRIBED
  UNSUBSCRIBED
}

// NEW: Contact classification (for hiding subscriber records from Contacts UI)
enum ContactKind {
  NORMAL
  SUBSCRIBER
}

// Animals â€” constrained SKUs only
enum Species {
  DOG
  CAT
  HORSE
}

enum Sex {
  MALE
  FEMALE
}

enum AnimalStatus {
  ACTIVE
  UNAVAILABLE
  RETIRED
  DECEASED
  PROSPECT
}

// â”€â”€â”€â”€â”€ Existing (kept) for legacy BreedRegistryLink.registry â”€â”€â”€â”€â”€
enum Registry {
  AKC
  FCI
  TICA
  CFA
  WCF
  WBFSH
  USEF
  FEI
  JOCKEY_CLUB
  OTHER
}

enum BreedStatus {
  ACTIVE
  INACTIVE
  DEPRECATED
}

enum AliasKind {
  COMMON
  LEGACY
  MISSPELLING
}

// â”€â”€â”€â”€â”€ NEW: per-registry status for a breed â”€â”€â”€â”€â”€
enum RegistryStatus {
  RECOGNIZED // fully recognized / championship eligible
  PROVISIONAL // misc/foundation/experimental
  NOT_RECOGNIZED // explicitly not recognized
  DELISTED // used to be recognized, no longer is
  VARIANT // color/size/coat variant entry
}

// ------------------------------------------------------------
// Core/Auth Models
// ------------------------------------------------------------
model User {
  id            String  @id
  email         String? @unique
  name          String?
  hashedPass    String?
  emailVerified Boolean @default(false)

  // Optional 1:1 link to a Contact (for subscriber/portal)
  contactId Int?     @unique
  contact   Contact? @relation("UserContact", fields: [contactId], references: [id], onDelete: SetNull)

  memberships        Membership[]
  sessions           Session[]
  verificationTokens VerificationToken[]
  mfaTotps           MfaTotp[]
  recoveryCodes      RecoveryCode[]
  passkeys           Passkey[]
}

model Organization {
  id        Int      @id @default(autoincrement())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memberships         Membership[]
  contacts            Contact[]
  contactAffiliations ContactAffiliation[]

  // Animals owned by this org
  animals Animal[]

  // Invites issued that target this org (null org means "new account" invite)
  invites Invite[]

  // NEW: tenant-scoped custom breeds
  customBreeds CustomBreed[]
}

model Membership {
  id             Int    @id @default(autoincrement())
  userId         String
  organizationId Int
  role           Role   @default(STAFF)

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([userId, organizationId])
  @@index([organizationId])
}

model Session {
  id        String   @id
  userId    String
  expiresAt DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

model VerificationToken {
  id        String                @id
  userId    String?
  email     String?
  token     String                @unique
  type      VerificationTokenType
  expiresAt DateTime

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([email])
  @@index([expiresAt])
}

model MfaTotp {
  id         String   @id
  userId     String
  secretHash String
  createdAt  DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model RecoveryCode {
  id        String    @id
  userId    String
  codeHash  String
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Passkey {
  id           String   @id
  userId       String
  credentialId String   @unique
  publicKey    Bytes
  signCount    Int
  transports   String?
  label        String?
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// ------------------------------------------------------------
// Contacts Module (UI-aligned)
// ------------------------------------------------------------
model Contact {
  id Int @id @default(autoincrement())

  // Names / display
  firstName   String  @default("")
  lastName    String  @default("")
  nickname    String?
  displayName String? // server mirror of (nickname || first + last)

  // Contact details
  email         String?
  phone         String?
  phoneType     String?
  whatsapp      Boolean? // nullable to match API (can be null)
  whatsappPhone String?

  // Address
  street     String?
  street2    String?
  city       String?
  state      String?
  postalCode String?
  country    String? // UI may send code or name; store as string

  // Status / lead
  status     ContactStatus @default(ACTIVE)
  leadStatus String?

  // Communication prefs & compliance
  commPrefs   Json? // { email?: bool, sms?: bool, phone?: bool, mail?: bool, ... }
  emailStatus CommStatus? // nullable per API (null = no explicit status)
  smsStatus   CommStatus? // nullable per API

  // NEW: classification for portal subscribers vs normal contacts
  kind ContactKind @default(NORMAL)

  // Dates
  lastContacted DateTime?
  nextFollowUp  DateTime?
  birthday      DateTime?

  // Misc
  notes String?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Primary Organization (nullable FK; keeps legacy behavior)
  organizationId Int?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: SetNull)

  // Many-to-many affiliations (new)
  affiliations ContactAffiliation[]

  // Children
  depositHolds   ContactDepositHold[]
  tagAssignments TagAssignment[]      @relation("ContactTags")

  // Backref for optional User.contact link
  user User? @relation("UserContact")

  // NEW: Animal ownership links
  animalOwners AnimalOwner[]

  // NEW: Back-relation for Animal.primaryOwner
  primaryOwnedAnimals Animal[] @relation("PrimaryOwner")

  // Soft delete / archival
  archivedAt     DateTime?
  archivedBy     String?
  archivedReason String?

  @@index([organizationId])
  @@index([kind]) // filter Contacts list to exclude SUBSCRIBER fast
}

model ContactAffiliation {
  id             Int      @id @default(autoincrement())
  contactId      Int
  organizationId Int
  createdAt      DateTime @default(now())

  contact      Contact      @relation(fields: [contactId], references: [id], onDelete: Cascade)
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([contactId, organizationId])
  @@index([contactId])
  @@index([organizationId])
}

model ContactDepositHold {
  id            Int     @id @default(autoincrement())
  contactId     Int
  contact       Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  groupName     String
  queuePosition Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([contactId])
}

// ------------------------------------------------------------
// Tags (support both Contacts and Animals; types stay separate)
// ------------------------------------------------------------
model Tag {
  id        Int      @id @default(autoincrement())
  name      String
  type      String // e.g. "contact", "animal", "breeding" (kept flexible)
  color     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  assignments TagAssignment[]

  @@unique([name, type], name: "name_type")
}

model TagAssignment {
  id         Int    @id @default(autoincrement())
  tagId      Int
  targetType String // "CONTACT" | "ANIMAL" | "BREEDING" (free-form for now)

  // Either contactId or animalId will be set (never both)
  contactId Int?
  animalId  String?

  tag Tag @relation(fields: [tagId], references: [id], onDelete: Cascade)

  // Back-relations for each target type
  contact Contact? @relation("ContactTags", fields: [contactId], references: [id], onDelete: SetNull)
  animal  Animal?  @relation("AnimalTags", fields: [animalId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Allow unique per-target while letting the other side be NULL
  @@unique([contactId, tagId], name: "contactId_tagId")
  @@unique([animalId, tagId], name: "animalId_tagId")
  @@index([tagId])
  @@index([contactId])
  @@index([animalId])
}

// ------------------------------------------------------------
// Invites (invite-only signup)
// ------------------------------------------------------------
model Invite {
  id             Int       @id @default(autoincrement())
  organizationId Int? // null => "new account" invite; set => join existing org
  email          String
  role           Role      @default(STAFF)
  token          String    @unique
  expiresAt      DateTime
  consumedAt     DateTime?

  organization Organization? @relation(fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([organizationId])
  @@index([email])
  @@index([expiresAt])
}

// ------------------------------------------------------------
// Auditing
// ------------------------------------------------------------
model AuditLog {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  entityType String // "contact" | "animal" ...
  entityId   String // e.g., contact.id (stringified for flexibility)
  action     String // e.g., "compliance_override"
  field      String?
  before     String?
  after      String?
  reason     String?
  userId     String?
  userEmail  String?
}

// ------------------------------------------------------------
// Animals Module
// ------------------------------------------------------------

model Breed {
  id   String @id @default(cuid())
  name String @unique

  // â”€â”€â”€ Canonical metadata (optional for existing rows)
  species Species?
  slug    String?      @unique // SEO/lookup key; nullable is fine for existing rows
  status  BreedStatus? @default(ACTIVE)
  origin  String?
  notes   String?

  // â”€â”€â”€ Canonical relationships
  aliases    BreedAlias[]
  registries BreedRegistryLink[]

  // Multi-breed join rows (existing)
  animalLinks AnimalBreed[]

  // Back-rel for Animal.breed (primary breed) (existing)
  primaryAnimals Animal[] @relation("PrimaryBreed")

  // Tenant custom mapping backref
  CustomBreed CustomBreed[]
}

// â”€â”€â”€ Canonical aliases for breeds
model BreedAlias {
  id      Int       @id @default(autoincrement())
  breedId String
  alias   String
  kind    AliasKind @default(COMMON)
  Breed   Breed     @relation(fields: [breedId], references: [id], onDelete: Cascade)

  @@unique([breedId, alias])
  @@index([alias])
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// NEW: Registry catalog (AKC, UKC, FCI, KC, CKC, CFA, TICA, â€¦)
// Kept separate from the legacy `Registry` enum so no breakage.
// Use this for multi-registry statuses via `BreedRegistryLink`.
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
model RegistryCatalog {
  id      String  @id @default(cuid())
  code    String  @unique // e.g. "AKC", "UKC", "FCI", "KC", "CKC", "CFA", "TICA"
  name    String
  country String?
  url     String?

  // single, named relation to BreedRegistryLink
  links BreedRegistryLink[] @relation("BreedRegistryCode")
}

// â”€â”€â”€ Canonical registry links (AKC/TICA/etc.) with per-registry status
model BreedRegistryLink {
  id Int @id @default(autoincrement())

  // Required core
  breedId String
  Breed   Breed  @relation(fields: [breedId], references: [id], onDelete: Cascade)

  // Legacy (kept, now optional)
  registry   Registry?
  registryId String?
  url        String?

  // Normalized reference to RegistryCatalog
  registryCode String?          // FK to RegistryCatalog.code
  registryRef  RegistryCatalog? @relation("BreedRegistryCode", fields: [registryCode], references: [code], onDelete: SetNull)

  // Per-registry status
  status      RegistryStatus? @default(RECOGNIZED) // optional, keep if you want normalized values later
  statusText  String?                            // <-- NEW: store raw JSON value verbatim

  since    Int?
  primary  Boolean?
  notes    String?
  proofUrl String?

  @@unique([breedId, registry, registryId])
  @@unique([breedId, registryCode])
  @@index([breedId])
  @@index([registryCode])
  @@index([status])
}

model Animal {
  id String @id @default(cuid())

  // Core identity
  name     String?
  callName String?
  species  Species?
  sex      Sex?
  status   AnimalStatus?

  // Dates
  birthDate DateTime?
  deathDate DateTime?

  // Registry / identifiers / appearance
  registration String?
  microchip    String?
  color        String?
  pattern      String?

  // Relations
  organizationId Int?
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: SetNull)

  primaryOwnerId Int?
  primaryOwner   Contact? @relation("PrimaryOwner", fields: [primaryOwnerId], references: [id], onDelete: SetNull)

  // Owner links (many-to-many via join)
  owners AnimalOwner[]

  // Breeds (primary + multi) â€” existing canonical relation
  breedId String?
  breed   Breed?        @relation("PrimaryBreed", fields: [breedId], references: [id])
  breeds  AnimalBreed[]

  // â”€â”€â”€ NEW: Optional multi-breed join for tenant custom breeds (no change to existing flows)
  customBreeds AnimalCustomBreed[]

  // Tags
  tagAssignments TagAssignment[] @relation("AnimalTags")

  // Weights (historical)
  weights WeightEntry[]

  // Optional pedigree links (self-relations)
  sireId String?
  sire   Animal? @relation("SireLink", fields: [sireId], references: [id])
  damId  String?
  dam    Animal? @relation("DamLink", fields: [damId], references: [id])

  // Back-relations for self relations (children)
  sireOf Animal[] @relation("SireLink")
  damOf  Animal[] @relation("DamLink")

  // Offspring groups (optional grouping, e.g., litters)
  offspringGroupsAsSire OffspringGroup[] @relation("SireGroups")
  offspringGroupsAsDam  OffspringGroup[] @relation("DamGroups")

  notes String?

  // Timestamps / archival
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  archived        Boolean?
  AnimalCycleDate AnimalCycleDate[]
  AnimalDocument  AnimalDocument[]

  @@index([organizationId])
  @@index([primaryOwnerId])
  @@index([breedId])
  @@index([sireId])
  @@index([damId])
}

model AnimalOwner {
  id        Int     @id @default(autoincrement())
  animalId  String
  contactId Int
  role      String?

  // NEW for ownership UI
  percent   Float?
  isPrimary Boolean @default(false)

  animal  Animal  @relation(fields: [animalId], references: [id], onDelete: Cascade)
  contact Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([animalId, contactId])
  @@index([contactId])
  @@index([animalId])
}

model AnimalBreed {
  id         Int    @id @default(autoincrement())
  animalId   String
  breedId    String
  percentage Float?

  animal Animal @relation(fields: [animalId], references: [id], onDelete: Cascade)
  breed  Breed  @relation(fields: [breedId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([animalId, breedId])
  @@index([breedId])
  @@index([animalId])
}

// â”€â”€â”€ NEW: Animals x CustomBreed (tenant-scoped join)
// Allows assigning org-specific custom breeds to animals
model AnimalCustomBreed {
  id            Int    @id @default(autoincrement())
  animalId      String
  customBreedId Int
  percentage    Float?

  animal      Animal      @relation(fields: [animalId], references: [id], onDelete: Cascade)
  customBreed CustomBreed @relation(fields: [customBreedId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([animalId, customBreedId])
  @@index([animalId])
  @@index([customBreedId])
}

model WeightEntry {
  id       Int      @id @default(autoincrement())
  animalId String
  takenAt  DateTime @default(now())
  weightKg Float

  animal Animal @relation(fields: [animalId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([animalId, takenAt])
}

model OffspringGroup {
  id         Int       @id @default(autoincrement())
  sireId     String?
  damId      String?
  occurredAt DateTime? // e.g., litter date or grouping date
  notes      String?

  sire Animal? @relation("SireGroups", fields: [sireId], references: [id], onDelete: SetNull)
  dam  Animal? @relation("DamGroups", fields: [damId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sireId])
  @@index([damId])
}

// ------------------------------------------------------------
// NEW: Animals â€” cycle dates & documents (for drawer v1)
// ------------------------------------------------------------
model AnimalCycleDate {
  id        Int      @id @default(autoincrement())
  animalId  String
  startDate DateTime
  note      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  animal Animal @relation(fields: [animalId], references: [id], onDelete: Cascade)

  @@index([animalId, startDate])
}

model AnimalDocument {
  id        Int      @id @default(autoincrement())
  animalId  String
  name      String
  note      String?
  url       String?
  createdAt DateTime @default(now())

  animal Animal @relation(fields: [animalId], references: [id], onDelete: Cascade)

  @@index([animalId])
}

// ------------------------------------------------------------
// NEW: Tenant-scoped Custom Breeds (do not leak across orgs)
// ------------------------------------------------------------
model CustomBreed {
  id             Int      @id @default(autoincrement())
  organizationId Int
  species        Species? // optional to avoid forcing a backfill now
  name           String

  // optional mapping to a canonical breed (helps analytics/search)
  canonicalBreedId String?
  Canonical        Breed?  @relation(fields: [canonicalBreedId], references: [id])

  // org-defined aliases
  aliases CustomBreedAlias[]

  // back-ref to animals via AnimalCustomBreed join
  animalLinks AnimalCustomBreed[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([organizationId, name]) // allow same name in different orgs
  @@index([organizationId, name])
  @@index([canonicalBreedId])
}

model CustomBreedAlias {
  id            Int    @id @default(autoincrement())
  customBreedId Int
  alias         String

  CustomBreed CustomBreed @relation(fields: [customBreedId], references: [id], onDelete: Cascade)

  @@unique([customBreedId, alias])
  @@index([alias])
}
