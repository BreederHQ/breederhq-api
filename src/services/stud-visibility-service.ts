// src/services/stud-visibility-service.ts
/**
 * Stud Listing Visibility Service
 *
 * Handles visibility configuration for stud listings with inheritance hierarchy:
 * TENANT (defaults) → PROGRAM (stud service program) → PARTICIPANT (individual stallion)
 *
 * Each level can inherit settings from parent and optionally override specific fields.
 */

import prisma from "../prisma.js";

// =============================================================================
// Types
// =============================================================================

/**
 * Type will be generated by Prisma after migration
 * Using string literal type until then
 */
type StudVisibilityLevel = "TENANT" | "PROGRAM" | "PARTICIPANT";

/**
 * Visibility rule entity type (matches Prisma model after migration)
 */
interface StudVisibilityRuleEntity {
  id: number;
  tenantId: number;
  level: StudVisibilityLevel;
  levelId: string;
  inheritsFromId: number | null;
  config: unknown;
  enabled: boolean;
  createdAt: Date;
  updatedAt: Date;
  createdBy: number | null;
  updatedBy: number | null;
}

/**
 * Visibility section for booking data
 */
interface BookingVisibilitySection {
  enabled: boolean;
  showSlotsAvailable?: boolean;
  showTotalSlots?: boolean;
  showSeasonDates?: boolean;
  showAcceptingBookings?: boolean;
  showHealthCertRequired?: boolean;
  showCogginsRequired?: boolean;
  showCultureRequired?: boolean;
  showUterineExamRequired?: boolean;
  showRequirementsNotes?: boolean;
  showBookingFee?: boolean;
  showFullFee?: boolean;
  showFeeRange?: boolean;
  showPaymentTerms?: boolean;
  showGuaranteeType?: boolean;
  showGuaranteeTerms?: boolean;
  showShippingAvailable?: boolean;
  showShippingRegions?: boolean;
  showShippingFee?: boolean;
}

/**
 * Visibility section for semen inventory data
 */
interface SemenVisibilitySection {
  enabled: boolean;
  showStorageTypes?: boolean;
  showDosesAvailable?: boolean;
  showStorageFacility?: boolean;
  showQualityGrade?: boolean;
  showMotility?: boolean;
  showMorphology?: boolean;
  showConcentration?: boolean;
  showCollectionDates?: boolean;
  showCollectionMethod?: boolean;
  showExpirationDates?: boolean;
  showBatchInfo?: boolean;
}

/**
 * Visibility section for calendar/scheduling data
 */
interface CalendarVisibilitySection {
  enabled: boolean;
  showAvailableDates?: boolean;
  showBlockedPeriods?: boolean;
  showBookedDates?: boolean;
  showCollectionDays?: boolean;
  showNextAvailable?: boolean;
  showLiveCoverAvailable?: boolean;
  showAIFreshAvailable?: boolean;
  showAIFrozenAvailable?: boolean;
  showShippingOptions?: boolean;
}

/**
 * Visibility section for performance/success data
 */
interface PerformanceVisibilitySection {
  enabled: boolean;
  showSuccessRate?: boolean;
  showTotalBreedings?: boolean;
  showCompletedBreedings?: boolean;
  showCurrentPregnancies?: boolean;
  showYearlyBreedings?: boolean;
  showLifetimeStats?: boolean;
  showCurrentSeason?: boolean;
  showBookingCount?: boolean;
}

/**
 * Visibility section for breeding terms
 */
interface BreedingTermsVisibilitySection {
  enabled: boolean;
  showMethods?: boolean;
  showPreferredMethod?: boolean;
  showMareAgeRequirements?: boolean;
  showMareBreedRequirements?: boolean;
  showMareHealthRequirements?: boolean;
  showContractRequired?: boolean;
  showContractTerms?: boolean;
  showBestTimeToBreed?: boolean;
  showSeasonalAvailability?: boolean;
}

/**
 * Complete visibility configuration
 */
export interface StudVisibilityConfig {
  booking?: BookingVisibilitySection;
  semen?: SemenVisibilitySection;
  calendar?: CalendarVisibilitySection;
  performance?: PerformanceVisibilitySection;
  breedingTerms?: BreedingTermsVisibilitySection;
  version?: number;
  lastUpdatedAt?: string;
  lastUpdatedBy?: number;
}

/**
 * Chain item in inheritance hierarchy
 */
interface InheritanceChainItem {
  level: StudVisibilityLevel;
  levelId: string;
  ruleId?: number;
  name?: string;
}

/**
 * Effective visibility with source tracking
 */
export interface EffectiveStudVisibility {
  level: StudVisibilityLevel;
  levelId: string;
  config: StudVisibilityConfig;
  inheritanceChain: InheritanceChainItem[];
  fieldSources?: Record<string, StudVisibilityLevel>;
}

// =============================================================================
// Default Configuration
// =============================================================================

const DEFAULT_STUD_VISIBILITY_CONFIG: StudVisibilityConfig = {
  booking: {
    enabled: true,
    showSlotsAvailable: true,
    showTotalSlots: false,
    showSeasonDates: true,
    showAcceptingBookings: true,
    showHealthCertRequired: true,
    showCogginsRequired: true,
    showCultureRequired: true,
    showUterineExamRequired: true,
    showRequirementsNotes: false,
    showBookingFee: true,
    showFullFee: true,
    showFeeRange: false,
    showPaymentTerms: false,
    showGuaranteeType: true,
    showGuaranteeTerms: false,
    showShippingAvailable: true,
    showShippingRegions: false,
    showShippingFee: false,
  },
  semen: {
    enabled: true,
    showStorageTypes: true,
    showDosesAvailable: false,
    showStorageFacility: false,
    showQualityGrade: true,
    showMotility: false,
    showMorphology: false,
    showConcentration: false,
    showCollectionDates: false,
    showCollectionMethod: false,
    showExpirationDates: false,
    showBatchInfo: false,
  },
  calendar: {
    enabled: true,
    showAvailableDates: true,
    showBlockedPeriods: false,
    showBookedDates: false,
    showCollectionDays: false,
    showNextAvailable: true,
    showLiveCoverAvailable: true,
    showAIFreshAvailable: true,
    showAIFrozenAvailable: true,
    showShippingOptions: true,
  },
  performance: {
    enabled: false,
    showSuccessRate: false,
    showTotalBreedings: false,
    showCompletedBreedings: false,
    showCurrentPregnancies: false,
    showYearlyBreedings: false,
    showLifetimeStats: false,
    showCurrentSeason: false,
    showBookingCount: false,
  },
  breedingTerms: {
    enabled: true,
    showMethods: true,
    showPreferredMethod: false,
    showMareAgeRequirements: true,
    showMareBreedRequirements: true,
    showMareHealthRequirements: true,
    showContractRequired: true,
    showContractTerms: false,
    showBestTimeToBreed: false,
    showSeasonalAvailability: true,
  },
  version: 1,
};

// =============================================================================
// Prisma Access Helper
// =============================================================================

/**
 * Get the studVisibilityRule model from Prisma
 * Uses type cast since model won't exist until migration runs
 */
function getStudVisibilityRuleModel() {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return (prisma as any).studVisibilityRule;
}

// =============================================================================
// Utility Functions
// =============================================================================

/**
 * Deep merge two objects, with source values overriding target
 */
function deepMerge<T extends Record<string, unknown>>(
  target: T,
  source: Partial<T>
): T {
  const result = { ...target };

  for (const key of Object.keys(source) as Array<keyof T>) {
    const sourceValue = source[key];
    const targetValue = result[key];

    if (
      sourceValue !== undefined &&
      typeof sourceValue === "object" &&
      sourceValue !== null &&
      !Array.isArray(sourceValue) &&
      typeof targetValue === "object" &&
      targetValue !== null &&
      !Array.isArray(targetValue)
    ) {
      // Recursively merge objects
      result[key] = deepMerge(
        targetValue as Record<string, unknown>,
        sourceValue as Record<string, unknown>
      ) as T[keyof T];
    } else if (sourceValue !== undefined) {
      result[key] = sourceValue as T[keyof T];
    }
  }

  return result;
}

/**
 * Track which level each field value came from
 */
function trackFieldSources(
  configs: Array<{ level: StudVisibilityLevel; config: StudVisibilityConfig }>
): Record<string, StudVisibilityLevel> {
  const sources: Record<string, StudVisibilityLevel> = {};

  // Process from parent to child (later configs override)
  for (const { level, config } of configs) {
    for (const [sectionKey, section] of Object.entries(config)) {
      if (section && typeof section === "object") {
        for (const [fieldKey, value] of Object.entries(
          section as Record<string, unknown>
        )) {
          if (value !== undefined) {
            sources[`${sectionKey}.${fieldKey}`] = level;
          }
        }
      }
    }
  }

  return sources;
}

// =============================================================================
// Core Service Functions
// =============================================================================

/**
 * Get the inheritance chain from root to the specified level
 */
export async function getInheritanceChain(
  tenantId: number,
  level: StudVisibilityLevel,
  levelId: string
): Promise<InheritanceChainItem[]> {
  const chain: InheritanceChainItem[] = [];

  // Always start with tenant
  chain.push({
    level: "TENANT",
    levelId: String(tenantId),
  });

  if (level === "TENANT") return chain;

  // If PROGRAM or PARTICIPANT, we need the program
  if (level === "PROGRAM") {
    chain.push({
      level: "PROGRAM",
      levelId,
    });
  } else if (level === "PARTICIPANT") {
    // Get the program ID for this participant
    const participant = await prisma.animalProgramParticipant.findUnique({
      where: { id: parseInt(levelId, 10) },
      select: { programId: true },
    });

    if (participant) {
      chain.push({
        level: "PROGRAM",
        levelId: String(participant.programId),
      });
    }

    chain.push({
      level: "PARTICIPANT",
      levelId,
    });
  }

  // Look up rule IDs for each level
  const model = getStudVisibilityRuleModel();
  for (const item of chain) {
    try {
      const rule = await model.findUnique({
        where: {
          tenantId_level_levelId: {
            tenantId,
            level: item.level,
            levelId: item.levelId,
          },
        },
        select: { id: true },
      });
      if (rule) {
        item.ruleId = rule.id;
      }
    } catch {
      // Model doesn't exist yet (pre-migration) - continue without rule IDs
    }
  }

  return chain;
}

/**
 * Get effective visibility config by resolving inheritance chain
 */
export async function getEffectiveVisibility(
  tenantId: number,
  level: StudVisibilityLevel,
  levelId: string
): Promise<EffectiveStudVisibility> {
  // Build inheritance chain
  const chain = await getInheritanceChain(tenantId, level, levelId);

  // Collect rules from each level
  const rulesWithConfigs: Array<{
    level: StudVisibilityLevel;
    config: StudVisibilityConfig;
  }> = [];

  const model = getStudVisibilityRuleModel();
  for (const item of chain) {
    try {
      const rule = await model.findUnique({
        where: {
          tenantId_level_levelId: {
            tenantId,
            level: item.level,
            levelId: item.levelId,
          },
        },
      });

      if (rule && rule.enabled) {
        rulesWithConfigs.push({
          level: item.level,
          config: rule.config as StudVisibilityConfig,
        });
      }
    } catch {
      // Model doesn't exist yet (pre-migration) - use defaults only
    }
  }

  // Start with defaults and merge each level's config
  let effectiveConfig = { ...DEFAULT_STUD_VISIBILITY_CONFIG };
  for (const { config } of rulesWithConfigs) {
    effectiveConfig = deepMerge(
      effectiveConfig,
      config as Record<string, unknown>
    ) as StudVisibilityConfig;
  }

  // Track which level each field came from
  const fieldSources = trackFieldSources([
    { level: "TENANT", config: DEFAULT_STUD_VISIBILITY_CONFIG },
    ...rulesWithConfigs,
  ]);

  return {
    level,
    levelId,
    config: effectiveConfig,
    inheritanceChain: chain,
    fieldSources,
  };
}

/**
 * Create or update a visibility rule at a specific level
 */
export async function upsertVisibilityRule(
  tenantId: number,
  level: StudVisibilityLevel,
  levelId: string,
  config: Partial<StudVisibilityConfig>,
  options?: {
    enabled?: boolean;
    inheritsFromId?: number;
    updatedBy?: number;
  }
): Promise<StudVisibilityRuleEntity> {
  const now = new Date().toISOString();

  // Determine parent rule if inheriting
  let parentRuleId = options?.inheritsFromId;
  if (!parentRuleId && level !== "TENANT") {
    // Auto-determine parent
    const chain = await getInheritanceChain(tenantId, level, levelId);
    const parentItem = chain[chain.length - 2]; // Second to last is parent
    if (parentItem?.ruleId) {
      parentRuleId = parentItem.ruleId;
    }
  }

  // Add metadata to config
  const configWithMeta = {
    ...config,
    lastUpdatedAt: now,
    lastUpdatedBy: options?.updatedBy,
  };

  const model = getStudVisibilityRuleModel();
  const rule = await model.upsert({
    where: {
      tenantId_level_levelId: {
        tenantId,
        level,
        levelId,
      },
    },
    create: {
      tenantId,
      level,
      levelId,
      config: configWithMeta,
      enabled: options?.enabled ?? true,
      inheritsFromId: parentRuleId,
      createdBy: options?.updatedBy,
      updatedBy: options?.updatedBy,
    },
    update: {
      config: configWithMeta,
      enabled: options?.enabled,
      inheritsFromId: parentRuleId,
      updatedBy: options?.updatedBy,
    },
  });

  return rule as StudVisibilityRuleEntity;
}

/**
 * Create an override at a child level
 */
export async function createOverride(
  tenantId: number,
  level: StudVisibilityLevel,
  levelId: string,
  overrideConfig: Partial<StudVisibilityConfig>,
  updatedBy?: number
): Promise<StudVisibilityRuleEntity> {
  // Get the current effective config first
  const effective = await getEffectiveVisibility(tenantId, level, levelId);

  // Merge the override with existing config
  const mergedConfig = deepMerge(
    effective.config as Record<string, unknown>,
    overrideConfig as Record<string, unknown>
  ) as StudVisibilityConfig;

  return upsertVisibilityRule(tenantId, level, levelId, mergedConfig, {
    updatedBy,
  });
}

/**
 * Delete a rule (reverts to parent inheritance)
 */
export async function deleteVisibilityRule(
  tenantId: number,
  level: StudVisibilityLevel,
  levelId: string
): Promise<{ success: boolean }> {
  const model = getStudVisibilityRuleModel();
  await model.deleteMany({
    where: {
      tenantId,
      level,
      levelId,
    },
  });

  return { success: true };
}

/**
 * List all visibility rules for a tenant
 */
export async function listVisibilityRules(
  tenantId: number,
  filters?: {
    level?: StudVisibilityLevel;
    levelId?: string;
  }
): Promise<StudVisibilityRuleEntity[]> {
  const where: Record<string, unknown> = {
    tenantId,
  };

  if (filters?.level) {
    where.level = filters.level;
  }

  if (filters?.levelId) {
    where.levelId = filters.levelId;
  }

  const model = getStudVisibilityRuleModel();
  try {
    const rules = await model.findMany({
      where,
      orderBy: [{ level: "asc" }, { createdAt: "asc" }],
    });
    return rules as StudVisibilityRuleEntity[];
  } catch {
    // Model doesn't exist yet (pre-migration)
    return [];
  }
}

/**
 * Get a single rule by ID
 */
export async function getVisibilityRule(
  tenantId: number,
  ruleId: number
): Promise<StudVisibilityRuleEntity | null> {
  const model = getStudVisibilityRuleModel();
  try {
    const rule = await model.findFirst({
      where: {
        id: ruleId,
        tenantId,
      },
    });
    return rule as StudVisibilityRuleEntity | null;
  } catch {
    // Model doesn't exist yet (pre-migration)
    return null;
  }
}

/**
 * Ensure tenant has a default visibility rule
 * Called lazily on first access
 */
export async function ensureTenantDefaults(
  tenantId: number
): Promise<StudVisibilityRuleEntity | null> {
  const model = getStudVisibilityRuleModel();

  try {
    const existing = await model.findUnique({
      where: {
        tenantId_level_levelId: {
          tenantId,
          level: "TENANT",
          levelId: String(tenantId),
        },
      },
    });

    if (existing) {
      return existing as StudVisibilityRuleEntity;
    }

    const created = await model.create({
      data: {
        tenantId,
        level: "TENANT",
        levelId: String(tenantId),
        config: DEFAULT_STUD_VISIBILITY_CONFIG,
        enabled: true,
      },
    });

    return created as StudVisibilityRuleEntity;
  } catch {
    // Model doesn't exist yet (pre-migration) - return null
    return null;
  }
}

/**
 * Disable inheritance from a parent level by copying the effective config locally
 */
export async function disableInheritance(
  tenantId: number,
  currentLevel: StudVisibilityLevel,
  currentLevelId: string,
  updatedBy?: number
): Promise<StudVisibilityRuleEntity> {
  // Get the effective config (resolved from all parents)
  const effective = await getEffectiveVisibility(
    tenantId,
    currentLevel,
    currentLevelId
  );

  // Create/update a rule at this level with the full config
  // This "snapshots" the current effective state locally
  return upsertVisibilityRule(
    tenantId,
    currentLevel,
    currentLevelId,
    effective.config,
    {
      inheritsFromId: undefined, // Break inheritance link
      updatedBy,
    }
  );
}

/**
 * Get the default visibility config (for reference/initialization)
 */
export function getDefaultConfig(): StudVisibilityConfig {
  return { ...DEFAULT_STUD_VISIBILITY_CONFIG };
}
